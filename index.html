<!DOCTYPE html>
<html>

<head>
<script src="https://code.angularjs.org/1.3.9/angular.js"></script>
<script src="https://x2js.googlecode.com/hg/xml2json.js"></script>
<script>
angular.module('xemle.xml' [])
.filter('textToXml', [
    '$window',
    '$log',
    function($window, $log) {
      return function(input) {
        var xml;
        if ('DOMParser' in $window) {
          var parser = new DOMParser();
          try {
            xml = parser.parseFromString(input, 'text/xml');
          } catch (e) {
            $log.error('Could not parse input: ' + input);
            throw e;
          }
        } else if ('ActiveXObject' in $window) {
          xml = new ActiveXObject('Microsoft.XMLDOM');
          if (!xml) {
            $log.error('Not not load XMLDOM');
          } else {
            try {
              xml.async = false;
              xml.loadXML(input);
            } catch (e) {
              $log.error('Could not parse input: ' + input);
              throw e;
            }
          }
        }
        return xml;
      }
    }
  ])
.filter('xmlToJson', [
    function() {
      function nodeName(node) {
        if (node.nodeType == 3) {
          return 'value';
        }
        return node.localName || node.nodeName;
      }

      // based from http://davidwalsh.name/convert-xml-json
      // Changes XML to JSON
      function xmlToJson(xml) {
        
        // Create the return object
        var obj = {};

        if (xml.prefix) {
          obj['@ns'] = {
            prefix: xml.prefix,
            URI: xml.namespaceURI
          }
        }
        if (xml.nodeType === 1) { // element
          // do attributes
          if (xml.attributes.length > 0) {
            obj['@attributes'] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
              var attribute = xml.attributes.item(j),
                  name = nodeName(attribute);

              obj['@attributes'][name] = xmlToJson(attribute);
            }
          }
        } else if (xml.nodeType === 2 || xml.nodeType === 3) { // attribute and text
          return xml.nodeValue;
        }

        // do children
        if (xml.hasChildNodes()) {
          for(var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i),
                name = nodeName(item);

            if (typeof(obj[name]) == 'undefined') {
              obj[name] = xmlToJson(item);
            } else {
              if (typeof(obj[name].push) == 'undefined') {
                var old = obj[name];
                obj[name] = [];
                obj[name].push(old);
              }
              obj[name].push(xmlToJson(item));
            }
          }
        }
        return obj;
      };        

      return function(input) {
        return xmlToJson(input);
      }
    }
  ]);
angular.module('xemle.webdav', ['xemle.xml'])
.constant('webdav', {
    host: 'https://i13s.de',
    path: '/box/remote.php/webdav',
    username: 'sebastian',
    password: '3lGXoD3IyP'
  })
.config([
    '$httpProvider',
    'webdav',
    function($httpProvider, webdav) {
      $httpProvider.defaults.headers.common['Authorization'] = 'Basic ' + btoa(webdav.username + ':' + webdav.password);
    }
  ])
.factory('WebdavService', [
    '$http',
    '$filter',
    'webdav',
    function ($http, $filter, webdav) {
      function canonicalUrl() {
        var args = Array.prototype.slice.call(arguments);

        return args.map(function(part) {
          return part.replace(/(^\/|\/$)*/g, '');
        }).filter(function(part) {
          return !!part;
        }).join('/');
      };

      function appendTransform(defaults, transform) {
        defaults = angular.isArray(defaults) ? defaults : [defaults];
        return defaults.concat(transform);
      };

      function isXml(contentType) {
        return contentType.test(/^\w+\/xml/);
      };

      function transformXmlToJson(data, headers) {
        if (isXml(headers('Content-Type')) {
          var xml = $filter('textToXml')(data),
              json = $filter('xmlToJson')(xml);
          
          return json;
        }
      };

      function action(path, options) {
        options = options || {};
        
        return $http({
          method: options.method || 'GET',
          url: canonicalUrl(webdav.host, webdav.path, path),
          data: options.data,
          transformResponse: appendTransform($http.defaults.transformResponse, transformXmlToJson)
        });
      };
     
      /**
       * Simplyfy propfind response
       */
      function mapPropfindResponse(response) {
        var obj = {};
        obj.path = response.href.value.replace(webdav.path, '');
        obj.isDir = !!(response.propstat.prop.resourcetype.collection);
        angular.forEach(response.propstat.prop, function(value, key) {
          if (!key.match(/^@/) && key !== 'resourcetype') {
            obj[key] = value.value;
          }
        });
        return obj;
      };
 
      return {
        ls: function(path) {
          return action(path, {
            method: 'PROPFIND',
            url: canonicalUrl(webdav.host, webdav.path, path)
          }).then(function (response) {
            if (response.status === 207) {
              var responses = response.data.multistatus.response || [];
              if (!angular.isArray(responses)) {
                responses = [responses];
              }
              return responses.map(mapPropfindResponse);
            }
          }, function(err) {
            console.log(err);
          });
        },
        mkdir: function(path) {
          return $http({
            method: 'MKCOL',
            url: canonicalUrl(webdav.host, webdav.path, path)
          });
        },
        create: function(path, data, options) {
          options = options || {};
          return $http({
            method: option.method || 'PUT',
            url: canonicalUrl([webdav.host, webdav.path, path]),
            headers: {
              'Content-Type': options.contentType || 'application/octet-stream'
            },
            data: data
          });
        },
        read: function(path) {
          
        },
        update: function(path, data, options) {
          options = angular.extend({}, options || {});
          options.method = 'POST'; 
          return this.create(path, data, options);
        }
      };
    }
  ]);
angular.module('app', ['ngWebdav'])
.controller('AppCtrl', [
    '$scope',
    'WebdavService',
    function($scope, WebdavService) {
      $scope.ls = function(path) {
        WebdavService.ls(path).then(function (data) {
          $scope.data = data;
        });  
      };
      $scope.mkdir = function(path) {
        webdavService.mkdir(path);
      };
      $scope.create = function(path, data) {
        WebdavService.create(path, data);
      };
      $scope.update = function(path, data) {
        WebdavService.update(path, data);
      }

      $scope.ls('/');
    }
  ]);
</script>
</head>

<body ng-app="app" ng-controller="AppCtrl">

<div>
  <p>Name: <input type="text" ng-model="name"></p>
  <p ng-bind="name"></p>
</div>

<h1>Webdav</h1>
<p>Status {{ status }}</p>
<ul>
  <li ng-repeat="f in data">{{f.path}} ({{f.isDir}}) <span ng-click="ls(f.path)">cd</span></li>
</ul>

<textarea ng-model="text"></textarea>
<input
</body>
</html>
